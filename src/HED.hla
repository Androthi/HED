
	// Quick jumps, double click word below and F3
	// menu_tbl
	// WndProc
	
program HED_MAIN;
	
	
	// system and local includes
	#includeonce	("HED.hhf")
	#includeonce	("args.hhf")
	#includeonce	("fileio.hhf")
	#includeonce	("filesys.hhf")
	#includeonce	("memory.hhf")
	#includeonce	("stdin.hhf")

	// global compile-time settings
	?@nodisplay:=true;
	?@align:=4;
	?@noalignstack := true;
	
	//===============================================================
	// locals

	const
	
		// status bar positionals
		POS_LINES				:=160;
		POS_INS					:=POS_LINES+31;

		// increase this when a new Panel window is added, "Fold" is Window #0
		nPanelWindows			:= 2;

		IDM_HED_COLLAPSEALL	:= $0fffC;
		IDM_HED_EXPANDALL		:= $0FFFD;

		HED_DEFAULTINI			:="Data" + dirsep_c + "hed_default.ini";
		HED_INI_FILE			:="Data" + dirsep_c + "HED.ini";
		raseledi				:text:= "(type RASELCHANGE [edi])";
		rabecx					:text:= "(type RABLOCKDEF [ecx])";

	static	// local
		align(4);
		// parts : Ln : lines | ins | -
	 	parts		:int32[STATUS_PARTS]:=[POS_LINES,POS_INS,-1];
	
		RadDLL			:str.constant("Data\RAEdit.dll");
		linefont		:w.LOGFONT:=w.LOGFONT:[-12,0,0,0,400,0,0,0,0,3,2,1,49,strToBA("Lucida Console",w.LF_FACESIZE)];
		current_menu	:uns16 := RECENT_MENU_START;		// track auto-added menus current number
		align (4);

	storage	// local variables
		align(4);
		argc		:uns32;		// command line arguments
		prvline		:dword;
		hradll		:dword;		// dll handle
		nlastline	:dword;		// check for last line in edit control
		openfile_s	:string;
				
		wc			:w.WNDCLASSEX;
		msg			:w.MSG;
		pt			:hide.point_t;

		cf			:w.CHOOSEFONT;
		chrg		:w.CHARRANGE;	
		wordbuf		:byte[300];
		
		updateIns		:boolean;
		open_override	:boolean;

		align(4);
	
	readonly
		align(4);

		ClassName	:mzstr ("HEDClass");
		szCmntStart	:mzstr ("/*");	//*/
		szCmntEnd	:mzstr ("*/");
	
		szINS		:mzstr ( "INS");
		szOVR		:mzstr ( "OVR");
		
//bm=custom keys
	static
		UserKey_table	:UserKey; @nostorage;
		UserKey
			UserKey:[ key_ctrl, w.VK_N, IDM_FILE_NEW],
			UserKey:[ key_ctrl, w.VK_O, IDM_FILE_OPEN],
			UserKey:[ 0, 0, IDM_FILE_INSERT],
			UserKey:[ key_alt, w.VK_O, IDM_FILE_OPEN_FOLDER],
			UserKey:[ key_ctrl, w.VK_S, IDM_FILE_SAVE],
			UserKey:[ key_alt, w.VK_S , IDM_FILE_SAVEAS],
			UserKey:[ ctrl_shift, w.VK_S, IDM_FILE_SAVEALL],
			UserKey:[ key_ctrl, w.VK_F4, IDM_FILE_CLOSE],
			UserKey:[ ctrl_shift, w.VK_F4, IDM_FILE_CLOSEALL],
			UserKey:[ 0, w.VK_ESCAPE, IDM_FILE_EXIT],
			UserKey:[ key_ctrl, w.VK_Z, IDM_EDIT_UNDO],
			UserKey:[ key_ctrl, w.VK_Y, IDM_EDIT_REDO],
			UserKey:[ key_ctrl, w.VK_X, IDM_EDIT_CUT],
			UserKey:[ key_ctrl, w.VK_C, IDM_EDIT_COPY],
			UserKey:[ key_ctrl, w.VK_V, IDM_EDIT_PASTE],
			UserKey:[ key_ctrl, w.VK_D, IDM_EDIT_DELETE],
			UserKey:[ key_ctrl, w.VK_A, IDM_EDIT_SELECTALL],
			UserKey:[ key_ctrl, w.VK_F, IDM_EDIT_FIND],
			UserKey:[ 0, w.VK_F3, IDM_EDIT_NEXT],
			UserKey:[ key_ctrl, w.VK_F3, IDM_EDIT_PREV],
			UserKey:[ key_ctrl, w.VK_R, IDM_EDIT_REPLACE],
			UserKey:[ key_ctrl, w.VK_G, IDM_EDIT_GOTO],
			UserKey:[ key_shift, w.VK_F8, IDM_EDIT_SETMARK],
			UserKey:[ 0, w.VK_F8, IDM_EDIT_NEXTBOOK],
			UserKey:[ key_ctrl, w.VK_F8, IDM_EDIT_PREVBOOK],
			UserKey:[ 0, w.VK_F11, IDM_VIEW_OUTPUT],
			UserKey:[ key_ctrl, w.VK_B, IDM_VIEW_PANEL],
			UserKey:[ 0, w.VK_F12, IDM_VIEW_TOGGLE],
			UserKey:[ key_ctrl, w.VK_F12, IDM_VIEW_HIDEALL],

			UserKey:[ 0, 0, 0]; // end of keys

		//KeyboardState :byte[256];
		modkey	:dword := 0;
		
	proc
	
	UpdateMenu	:procedure;
	
		// adds dynamic menus > recent files, etc.
		var
			menustring	:string;
			count		:uns32;

		static
			_hmenu		:dword :=0;
			_openrecent	:mzstr ("Open Recent");
		
	begin UpdateMenu;
		pushad();
	
		if (_hmenu <> 0 ) then
			w.DestroyMenu (_hmenu);
			mov (0, _hmenu);
		endif;
	
		w.CreatePopupMenu();
		mov (eax, _hmenu);
	
		hed_ini.getItemCount ("Recent Files");
		mov (eax, count);
	
		mov (RECENT_MENU_START, ebx);
	
		xor (ecx, ecx);
		while (ecx < count ) do
			
			if (hed_ini.readItem ("Recent Files", ecx, stringbuffer)) then
		
				USE (ecx, ebx);
					w.AppendMenu ( _hmenu, w.MF_BYPOSITION | w.MF_ENABLED | w.MF_STRING,
									ebx, stringbuffer);
				ENDUSE;
				
			else
				error.warning ("'Recent Files' list in Data\HED.ini is corrupt");
				break;
			endif;
			
			inc (ebx);
			inc (ecx);
		endwhile;
		
		w.GetSubMenu (core.hmenu,0);
		w.ModifyMenu (eax, 4, w.MF_BYPOSITION | w.MF_POPUP| w.MF_ENABLED ,
						_hmenu, &_openrecent );
		w.DrawMenuBar(core.hwnd);
		//dbg.put ("done update menu");
		
		popad();
	end UpdateMenu;
	
	setupUserMenu	:procedure;
		var
			nmenus		:uns32;
		
		storage
			usermenu	:dword;
		
		readonly
			szUser	:zstring := "User Colors";
			
	begin setupUserMenu;
		USE (EBX, ESI, EDI);
		
		//dbg.put ("setupUserMenu");
		hed_ini.getItemCount ("User Menu");
		test (eax, eax);
		jz done;
		mov (eax, nmenus);
		
		scan.setDelimiters( commaDelimcst );
		
		w.CreatePopupMenu();
		mov (eax, usermenu);
	
		sub (ebx, ebx);
		while (ebx < nmenus) do
			hed_ini.readItem ("User Menu", ebx, stringbuffer);
			mov (stringbuffer, esi);
			scan.getToken( stringbuffer );
			str.trim( stringbuffer );
			
			mov (ebx, eax);
			add (USER_MENU_START, eax);
			USE (EBX);
				w.AppendMenu ( usermenu, w.MF_ENABLED | w.MF_STRING,
									eax, stringbuffer);
			ENDUSE;
			inc (ebx);
		endwhile;
	
		w.InsertMenu (core.hmenu, 7, w.MF_BYPOSITION | w.MF_POPUP | w.MF_STRING, usermenu, szUser);
		w.DrawMenuBar(core.hwnd);
		
		done:
		ENDUSE;
		//dbg.put ("/setupUserMenu");
	end setupUserMenu;

	findExecutable :procedure( source:string; dest:string )
		 { @returns("EAX") };
		 
		var
			src		:string;
			pth		:string;
			iso		:string;
			ext		:string;
			
	begin findExecutable;
		dbg.enters("findExecutable");
		mov( str.talloc(300), src );
		mov( str.talloc(300), pth );
		mov( str.talloc( 300), ext );
		mov (0, iso);
		
		if( filesys.hasExtension( source ) ) then
			filesys.extractExt( source, ext );
			//str.cpyz( eax, ext );
			dbg.put("ext = ", ext );
			if( str.ieq( ext, "exe" ) ) then
				
				filesys.extractFilename( source, src );
				filesys.extractPath( source, pth );
				w.FindExecutable( src, pth, &buffer );
				if( eax > 32 ) then
					str.cpyz( &buffer, dest );
					or( 1, eax );
				else
					xor( eax, eax );
				endif; 
			
			else
				xor( eax, eax );
				
			endif;
			dbg.put("eax = ", eax );
		else
			xor( eax, eax );
			
		endif;
		dbg.exits("findExecutable");
	end findExecutable;
	
	expandPathMacs :procedure(source:string; dest:string);
		var
			buf		:tBuffer;
			
	begin expandPathMacs;
//		dbg.enters("expandPathMacs");
		pushabi;
		
		buf.create();
		buf.puts( source );
		buf.bof();
		forever
			breakif(! buf.searchf ("%"));
			mov( buf.cursor,eax );
			mov( (type byte[eax+1]), bl );
			if (bl = 'p') then
				buf.puts( core.projectpath );
			elseif (bl = 'h') then
				buf.puts( core.homepath );
			elseif (bl = 's') then
				mov (curnode, eax);
				if (eax) then
					buf.puts( listeax.fullname );
				else
					toOutput (nl "WARNING: no current file; using %s macro" nl);
				endif;
			elseif( bl = 'b' ) then
				mov( curnode, eax );
				if( eax ) then
					filesys.extractBase( listeax.id, dest );
					buf.puts( dest );
				endif;
			elseif( bl = '$') then
				
				filesys.gwd( dest );
				buf.puts( dest );
			else
				// unknown, just skip it.
//				dbg.put("other");
				buf.right( 1 );
				continue;
			endif;
			buf.delete( 2 );
		endfor;
		buf.writeString( dest );
		buf.destroy();
//		dbg.put( "expanded :", dest );
		popabi;
//		dbg.exits("expandPathMacs");
	end expandPathMacs;
	
	procedure ProcessKeys (key:dword); @returns("EAX");
	begin ProcessKeys;

     	mov (&UserKey_table, edx);
		forever
			breakif ((type UserKey[edx]).command = 0);
			movzx ((type UserKey[edx]).modkeys, ecx);
			if (ecx = modkey) then
				mov ((type UserKey[edx]).vcode, al);
				mov ((type byte key), ah);
				breakif (ah = al);
			endif;
			add (@size(UserKey), edx);
		endfor;
		mov ((type UserKey[edx]).command, eax);
		if (!eax) then
			exit ProcessKeys;
		endif;
		w.SendMessage (core.hwnd, w.WM_COMMAND, EAX, 0);

		dbg.put ("/process keys :", eax);
	end ProcessKeys;

	
	//bm=edit proc

	procedure Proc_SubclassedEdit(lparam:dword; wparam:dword; umsg:uns32; hwin:dword);
	@alignstack;
	begin Proc_SubclassedEdit;
	USE(ESI, EDI, EBX, EDX);
	
		mov (curnode, ebx);
		if (! ebx) then
			jmp _exitnocall;
		endif;
	
		mov (umsg,eax);

   		if (eax = w.WM_SYSKEYDOWN) then
   			if (wparam = w.VK_MENU) then
        		// w.VK_MENU is sent by syskeydown message, as well as keydown message if
        		// alt is pressed after another modifier. such as control-alt 
        		dbg.put( "syskey down");
        		or (key_alt, modkey);
        		xor (eax, eax);
        		jmp _exitnocall;
        	elseif (wparam = w.VK_SHIFT) then
        		or (key_shift, modkey);
        		xor (eax, eax);
        		jmp _exitnocall;
        	endif;

		elseif (eax = w.WM_SYSKEYUP) then
			if (wparam = w.VK_MENU) then
     			and (!key_alt, modkey);
				xor (eax, eax);
        		jmp _exitnocall;
        	elseif (wparam = w.VK_SHIFT) then
        		dbg.put("up shift");
        		and (!key_shift, modkey);
        		xor (eax, eax);
        		jmp _exitnocall;
        	endif;
        		
        elseif (eax = w.WM_SYSCHAR) then
        	dbg.put ("syschar  :", wparam);
        	ProcessKeys (wparam);
        	jmp _exitnocall;
		
		elseif (eax = w.WM_KEYDOWN) then
     		if (wparam = w.VK_CONTROL) then
	     		or (key_ctrl, modkey);
	     	elseif (wparam = w.VK_SHIFT) then
	     		or (key_shift, modkey);
	     	elseif (wparam = w.VK_MENU) then
	     		or (key_alt, modkey);
			else
				ProcessKeys (wparam);
				
	    	endif;

		elseif (eax = w.WM_KEYUP) then
			if (wparam = w.VK_CONTROL) then
     			and (!key_ctrl, modkey);
			elseif (wparam = w.VK_SHIFT) then
				and (!key_shift, modkey);
			elseif (wparam = w.VK_MENU) then
				and (!key_alt, modkey);

			elseif(eax=w.VK_INSERT)	then
				mov (true, updateIns);
				
			elseif( eax = w.VK_PAUSE ) then
				
				//bm=debug
				dbg.enters("*****DEBUG*****");
				//w.DialogBoxParam( hinst, val ID_MANAGER, hwnd, &Proc_HEDManager, manager_jobs );
				dbg.exits("*****DEBUG*****");
			
			endif;

		endif;

		w.CallWindowProc ( listebx.oldhwnd, hwin, umsg, wparam, lparam);
		if (updateIns) then
			mov (false, updateIns);
			w.SendMessage(core.hwnd,HED_SETINSERTMODE,0,0);
		endif;
		_exitnocall:
	ENDUSE;
	end Proc_SubclassedEdit;

	procedure updateDisplay (toupdate:dword);

		procedure Toggle; @noframe;
		begin Toggle;
			USE (EAX, EDX);
				if (EAX) then
					mov(w.MF_BYCOMMAND | w.MF_ENABLED, eax);
				else
					mov(w.MF_BYCOMMAND | w.MF_GRAYED, eax);
				endif;
				w.EnableMenuItem (core.hmenu, edx, eax);
			ENDUSE;
			ret();
		end Toggle;

		procedure doEdit; @noframe;
		begin doEdit;
			w.SendMessage(listebx.hwnd, w.EM_CANUNDO, 0, 0);
			mov	(IDM_EDIT_UNDO, edx);
			Toggle();
			w.SendMessage(listebx.hwnd, w.EM_CANREDO,0,0);
			mov	(IDM_EDIT_REDO, edx);
			Toggle();
			w.SendMessage (listebx.hwnd, w.EM_EXGETSEL, 0, &chrg);
			mov	(chrg.cpMax, eax);
			sub	(chrg.cpMin, eax);
			mov	(IDM_EDIT_CUT, edx);
			Toggle();
			mov	(IDM_EDIT_COPY, edx);
			Toggle();
			mov	(IDM_EDIT_DELETE, edx);
			Toggle();
			w.SendMessage(listebx.hwnd, w.EM_CANPASTE, w.CF_TEXT,0);
			mov	(IDM_EDIT_PASTE, edx);
			Toggle();
			
			if (w.SendMessage (listebx.hwnd, w.EM_GETMODIFY, 0, 0)) then
				or( 1, eax );
			else
				xor( eax, eax );
			endif;
			mov(IDM_FILE_SAVE,edx);
			Toggle();
			
			ret();
		end doEdit;


		procedure doSelect; @noframe;
		begin doSelect;
			
				w.SendMessage(listebx.hwnd, w.EM_EXLINEFROMCHAR,0, chrg.cpMin);
				mov	(eax, edi);
				w.SendMessage(listebx.hwnd, REM_NXTBOOKMARK, edi,3);
				inc	(eax);
				mov	(IDM_EDIT_NEXTBOOK, edx);
				Toggle();
				w.SendMessage(listebx.hwnd, REM_PRVBOOKMARK, edi,3);
				inc	(eax);
				mov	(IDM_EDIT_PREVBOOK, edx);
				Toggle();
				w.SendMessage(listebx.hwnd, REM_NXTBOOKMARK,-1,3);
				inc	(eax);
				mov	(IDM_EDIT_CLEARBOOK,edx);
				Toggle();

			ret();
		end doSelect;

	begin updateDisplay;
		//dbg.put ("updateDisplay");
	USE (ESI, EDI, EBX);
		mov (toupdate, eax);
		switch (eax);
		case (update_general)
			// check to see if a node is open and update accordingly
			mov (curnode, ebx);
			if (ebx) then
				//dbg.put ("doselect");
				doEdit();
				doSelect();
				mov (true, eax);
				mov (IDM_EDIT_FIND, edx);
				Toggle();
				mov (IDM_EDIT_NEXT, EDX);
				Toggle();
				mov (IDM_EDIT_PREV, EDX);
				Toggle();
				mov (IDM_EDIT_REPLACE, edx);
				Toggle();
				mov (IDM_EDIT_GOTO, EDX);
				Toggle();
				mov (IDM_EDIT_FINDRETURN, EDX);
				Toggle();
				mov (IDM_EDIT_SELECTALL, edx);
			else
				xor (eax, eax);
				mov (IDM_EDIT_FIND, edx);
				Toggle();
				xor (eax, eax);
				mov (IDM_EDIT_NEXT, EDX);
				Toggle();
				mov (IDM_EDIT_PREV, EDX);
				Toggle();
				mov (IDM_EDIT_REPLACE, edx);
				Toggle();
				mov (IDM_EDIT_GOTO, EDX);
				Toggle();
				mov (IDM_EDIT_FINDRETURN, EDX);
				Toggle();
				mov	(IDM_EDIT_CUT, edx);
				Toggle();
				mov	(IDM_EDIT_COPY, edx);
				Toggle();
				mov	(IDM_EDIT_DELETE, edx);
				Toggle();
				mov (IDM_EDIT_SELECTALL, edx);
				Toggle();
				mov	(IDM_EDIT_UNDO, edx);
				Toggle();
				mov	(IDM_EDIT_REDO, edx);
				Toggle();
				mov	(IDM_EDIT_PASTE, edx);
				Toggle();
				mov	(IDM_EDIT_NEXTBOOK, edx);
				Toggle();
				mov	(IDM_EDIT_PREVBOOK, edx);
				Toggle();
				mov	(IDM_EDIT_CLEARBOOK,edx);
				Toggle();
				mov	(IDM_EDIT_NEXTBOOK, edx);
				Toggle();
				mov	(IDM_EDIT_PREVBOOK, edx);
				Toggle();
				mov	(IDM_EDIT_CLEARBOOK,edx);
				Toggle();
				mov (IDM_EDIT_SETMARK, EDX);
			endif;
		
			xor(eax,eax);

		case (update_selection)
			mov (curnode, ebx);
			doEdit();
			doSelect();
			
		default
		endswitch;
		
		fileList.getHead();
		mov (eax, ebx);
		while (ebx) do
			if( listebx.hwnd ) then
				if (w.SendMessage (listebx.hwnd, w.EM_GETMODIFY, 0, 0)) then
					break;
				endif;
			endif;
			mov( listebx.next, ebx );
		endwhile;

		mov( ebx, eax );
		mov(IDM_FILE_SAVEALL,edx);
		Toggle();


	ENDUSE;
	//dbg.put ("/updateDisplay");
	end updateDisplay;

	procedure hed_openFile (fname:string);
	begin hed_openFile;
		dbg.put ("hed_openFile");		
		if (RAEdit_open (fname)) then
			push (eax);
			mov( eax, ecx );
			tabtool_add ([ecx]);
			dbg.put ( listecx.fullname );
			Recent_Insert( listecx.fullname );
			UpdateMenu();
			updateDisplay (update_general);
			pop (eax);
		else
			xor (eax, eax);
		endif;
		dbg.put ("/hed_openFile");
	end hed_openFile;

	procedure hed_openNode ( var node:fList.fnode );
	begin hed_openNode;
	
	USE( EBX );
		mov( node, ebx );
		cmp( listebx.hwnd, 0 );	jne already_open;
		
		//dbg.put("3 :", listebx.fullname);
		RAEdit_new( [ebx] );
		if( filesys.exists( listebx.fullname) ) then
			
			RAEdit_loadFile( [ebx], listebx.fullname );
			dbg.put("post loadfile");
		else
			toOutput("File not found: ", listebx.fullname, nl );
		endif;
		
		tabtool_add( [ebx] );
		already_open:
	ENDUSE;
	//dbg.put("/hed_openNode");
	end hed_openNode;
 
 	procedure hed_selectNode( var node:fList.fnode );
 	begin hed_selectNode;
 		
 		// node already created and hwnd opened but invisible
 		// make it visible and update properties, create and attach
 		// a tabtool
 		
 		USE( EBX );
		 		
		mov( node, ebx );
		GetFileTime (listebx.fullname, listebx.writetime);
		RAEdit_setFormat ([ebx]);
		tabtool_add( [ebx] );
 		ENDUSE;
 		
 	end hed_selectNode;

 
 	procedure hed_closeNode ( var node:fList.fnode );
 	begin hed_closeNode;
		USE( EBX );
		mov( node, ebx );
		cmp( listebx.hwnd, 0 );	je already_closed;
		tabtool_close( [ebx] );
		w.DestroyWindow( listebx.hwnd );
		mov( 0, listebx.hwnd );
		already_closed:
		ENDUSE;
 	end hed_closeNode;

	procedure Menu_NewFile; @noframe;
	begin Menu_NewFile;
		RAEdit_openNew (NULL);
		tabtool_add ([eax]);
		updateDisplay (update_general);
		w.SetFocus( core.hwnd );
		ret();
	end Menu_NewFile;

	procedure Menu_OpenFile;	@noframe;
	begin Menu_OpenFile;
		dbg.put(">open");
		InitOF("Open File",NULL);
		if ( GetOpenName() ) then
			mov(eax,openfile_s);
			hed_openFile (openfile_s);
			str.free (openfile_s);
		endif;
		updateDisplay (update_general);
		ret();
	end Menu_OpenFile;
		
	procedure Menu_OpenFolder; @noframe;
	begin Menu_OpenFolder;
		GetOpenFolderName();
		if (eax) then
			toOutput ("Open Folder:", core.projectpath, nl );
			Explorer_LoadFolder (core.projectpath);
		endif;
		ret();
	end Menu_OpenFolder;

	
	procedure Menu_InsertFile;
	
		var
			buf		:tBuffer;
				

	begin Menu_InsertFile;
		dbg.put(">insert");
		pushabi;
		mov (curnode, ebx);
		if (ebx) then
			InitOF("Open File To Insert",NULL);
			if ( GetOpenName() ) then
				mov(eax,openfile_s);
				buf.create( openfile_s );
				mov( buf.data, eax );
				add( buf.length, eax );
				mov( 0, (type byte[eax]));
				w.SendMessage(listebx.hwnd,w.EM_REPLACESEL,true, buf.data);
				buf.destroy();
				str.free(openfile_s);
			endif;
			updateDisplay (update_general);
		endif;
		popabi;
	end Menu_InsertFile;
	
	procedure Menu_SaveFile;	@noframe;
	begin Menu_SaveFile;
		dbg.put("<save>");
		pushabi;
		mov (curnode, ebx);
		if (ebx) then
			if (listebx.hwnd > 0) then
				RAEdit_SaveFile ([ebx]);
			endif;
		endif;
		popabi;
		ret();
	end Menu_SaveFile;

	procedure Menu_SaveAs;
		var
			fname :string;
			
	begin Menu_SaveAs;
		mov (str.talloc(300), fname);
		pushabi;
		dbg.put("<saveas>");
		InitOF(	"Save File", NULL);
		if ( GetSaveName() ) then
			push (eax);
			str.cpy (eax, fname);
			pop (eax);
			str.free (eax);
			mov (curnode, ebx);
			WriteToFile (listebx.hwnd, fname);
			RAEdit_openNew (fname);
			tabtool_add ([eax]);
			updateDisplay (update_general);
			w.SetFocus( core.hwnd );
			filesys.gwd (workpath);
			Explorer_LoadFolder (workpath);
		endif;
		popabi;		
	end Menu_SaveAs;
		
	procedure Menu_SaveAll;	@noframe;
	begin Menu_SaveAll;
		dbg.put("<saveall>");
		saveAll();
		ret();
	end Menu_SaveAll;
	

	procedure Menu_CloseFile;	@noframe;
	begin Menu_CloseFile;
	USE (EBX);
		dbg.put ("close file");
		mov (curnode, ebx);
		if (ebx) then
			if (! querySave ([ebx])) then
				hed_closeNode( [ebx] );
				
					// orphaned file...
					// also remove from list and update treeview.
					fileList.remove ([ebx]);
			endif;
		endif;
		updateDisplay (update_general);
	ENDUSE;
	ret();	
	end Menu_CloseFile;
	
	procedure Menu_UserMenu;
	
		var
			taskstr	:string;
			optstr	:string;
			useoutput	:boolean;
			align( 4 );
			
	
	begin Menu_UserMenu;

		mov( str.talloc( 300 ), taskstr );
		mov( str.talloc( 100 ), optstr );
		mov( false, useoutput );
		
		USE (ESI, EBX);
		sub (USER_MENU_START, ecx);
		if (hed_ini.readItem ("User Menu", ecx, stringbuffer)) then
			
			scan.setDelimiters( commaDelimcst );
			mov( stringbuffer, esi );
			scan.getToken( taskstr );	// ignore the 1st one
			
			dbg.put("item: ", taskstr );
			
			jnc showerror;
			scan.getToken( taskstr );	// this is the task
			
			dbg.put("task: ", taskstr );
			
			jnc showerror;
			str.trim( taskstr );
			expandPathMacs ( taskstr, taskstr );
			dbg.put("expanded :", taskstr );
			
			scan.getToken( optstr );	// optional options
			dbg.put("options :", optstr );
			
			str.trim( optstr );
			if( str.ieq( optstr, "output" ) ) then
				mov( true, useoutput );
			endif;
			
			mov( taskstr, ebx );
			
			
			mov ([ebx], al);
			if (al = '<') then
				
				str.delete (taskstr, 0, 1);
				str.trim (taskstr);
				hed_openFile (taskstr);
				
			else
				
				if (findExecutable (taskstr, stringbuffer)) then
					str.put2 (stringbuffer, " """, taskstr, '"');
					str.cpy (stringbuffer,taskstr);
				endif;
				

				dbg.put ("running user :", taskstr);
				
				if( useoutput) then
					dbg.put("piping output");
					launchProgram( taskstr, true, true );
				else
					launchProgram( taskstr, false, false );
				endif;
					

			endif;
			
			jmp done;
			
			showerror:
				error.warning ("Unable to perform task, please doublecheck [User Menu] section in data/HED.ini" );
			done:
		endif;
		ENDUSE;
	end Menu_UserMenu;
	
	procedure Menu_RecentMenu; @noframe;
		// user selected item from 'Recent Files' under File menu.
	begin Menu_RecentMenu;
		dbg.put ("Recent Menu");
		
		sub (RECENT_MENU_START, ecx);
		if (hed_ini.readItem ("Recent Files", ecx, workpath)) then
			
			if( ecx > 0 ) then
				hed_ini.deleteItem( "Recent Files", ecx );
				hed_ini.insertItem( "Recent Files", 0, workpath );
				UpdateMenu(); // rebuild recent menu
			endif;
			
			filesys.extractExt( workpath, stringbuffer );

				if (filesys.exists (workpath)) then
					if (! selectOpen (workpath)) then
						hed_openFile (workpath);
					endif;
				else
					str.put (stringbuffer, "File not found :", workpath);
					error.warning (stringbuffer);
				endif;

		endif;
		updateDisplay (update_general);
		dbg.put("/Menu_recentMenu");
		ret();
	end Menu_RecentMenu;
	
	
	procedure Menu_CloseAll;	@noframe;
	begin Menu_CloseAll;
		closeAll();
		call SetWindowCaption;
		updateDisplay (update_general);
		ret();	
	end Menu_CloseAll;
	
	procedure Menu_PageSetup;	@noframe;
	begin Menu_PageSetup;

		// page setup
		call PageSetup;
		ret();
	end Menu_PageSetup;
	
	procedure Menu_Print;	@noframe;
	begin Menu_Print;
		// print
		call PrintDoc;
		ret();	
	end Menu_Print;

	procedure Menu_ToolsCalc; @noframe;
	begin Menu_ToolsCalc;
		launchProgram( "calc.exe", false, false );
		ret();
	end Menu_ToolsCalc;

	
	procedure Menu_ToolsConsole;	@noframe;
	begin Menu_ToolsConsole;
		
		env2.get( "COMSPEC", workpath );
		launchProgram( workpath, false, true );
		ret();
	end Menu_ToolsConsole;
	
	procedure Menu_ToolsRun; @noframe;
	begin Menu_ToolsRun;
		pushabi;
		
		if (! hed_ini._readString ("HED", "command", stringbuffer)) then
			str.cpy ("", stringbuffer);
		endif;
		
		if ( getStringInput( "Enter Command", stringbuffer, workpath )) then

			hed_ini.writeString ("HED", "command", workpath);
			expandPathMacs (workpath, workpath);
			toOutput (nl ">", workpath, nl);
			launchProgram( workpath, true, true );

		endif;
		
		popabi;
		ret();
	end Menu_ToolsRun;

	procedure Menu_ToolsColor;
		var
			cc		:w.CHOOSECOLOR;
			_str	:string;
		
	begin Menu_ToolsColor;
		lea (eax, cc);
		mem2.fillMem ([eax], @size(cc), 0);
		mov (@size (cc), eax);
		mov (eax, cc.lStructSize);
		push (core.hwnd);
		pop (cc.hwndOwner);
		mov (&CustColors, eax);
		mov (eax, cc.lpCustColors);
		mov(w.CC_FULLOPEN | w.CC_RGBINIT,cc.Flags);
		w._ChooseColor (cc);
		if (eax) then
			str.put (workpath, "$", cc.rgbResult);
			mov (curnode, eax);
			if (listeax.hwnd <> 0) then
				w.SendMessage (listeax.hwnd, w.EM_REPLACESEL, true, workpath);
			else
				str.insert (nl, 0, workpath);
				w.SendMessage(core.houtedt,w.EM_REPLACESEL, true,workpath);
			endif;
			w.SetFocus(core.hwnd);
		endif;
		
	end Menu_ToolsColor;
	
	procedure Menu_Help_About;
	begin Menu_Help_About;
		toOutput (
			"HED version ", hed_version, nl nl
			"Sevag Krikorian" nl
			"androth.pro@gmail.com" nl nl
			"Stripped down version of HIDE, made into a source agnostic editor" nl
			"https://github.com/Androthi/HED" nl );
	end Menu_Help_About;

	procedure Menu_Help_ShowEnv;
		var
			s	:string;
	
	begin Menu_Help_ShowEnv;
		
		mov (str.talloc (1024), s);
		
		toOutput (	
					"HED version ", hed_version, nl nl
					"HED Environment and Related Macros" nl
					"===================================" nl
					"%h home    : ", core.homepath, nl
					"%p project : ", core.projectpath,nl nl);

		filesys.gwd (workpath);
		toOutput (  "%$ current : ", workpath, nl);
		toOutput ("%s filename :");
		mov (curnode, eax);
		if (eax) then
			toOutput (listeax.id, nl);
		endif;
		toOutput( "%b basename :" );
		mov( curnode, eax );
		if( eax ) then
			filesys.extractBase( listeax.id, s );
			toOutput( s, nl );
		endif;
		
		env2.get ("PATH", s);
		toOutput (nl "   PATH     :", s, nl, nl); 
	
	end Menu_Help_ShowEnv;
	
	procedure Menu_Quit; @noframe;
	begin Menu_Quit;
		dbg.put ("menu quit");
		w.SendMessage(core.hwnd,w.WM_CLOSE,0,0);
		ret();
	end Menu_Quit;

	procedure Menu_ViewStatusbar;	@noframe;
	begin Menu_ViewStatusbar;
		xor(STATUS,settings.winview);
		test(STATUS,settings.winview);
		if (@nz) then
			w.ShowWindow(core.hsbr,w.SW_SHOWNA);
			w.CheckMenuItem(core.hmenu,IDM_VIEW_STATUS,(w.MF_BYCOMMAND | w.MF_CHECKED));
		else
			w.ShowWindow(core.hsbr,w.SW_HIDE);
			w.CheckMenuItem(core.hmenu,IDM_VIEW_STATUS,(w.MF_BYCOMMAND));
	    endif;
		w.SendMessage(core.hwnd,w.WM_SIZE,w.SIZENORMAL,1);
		ret();
	end Menu_ViewStatusbar;
	
	procedure Menu_ViewOutput;	@noframe;
	begin Menu_ViewOutput;
		// change output window view
		xor(OUTPUT,settings.winview);
		test(OUTPUT,settings.winview);
		if (@z) then
			Output_View(w.SW_HIDE);
		else
			Output_View(w.SW_SHOW);
	    endif;
		ret();
	end Menu_ViewOutput;
	
	procedure Menu_ViewPanel; @noframe;
	begin Menu_ViewPanel;
		PanelViewActive();
		ret();
	end Menu_ViewPanel;
	
	procedure Menu_ViewToggleWindows; @noframe;
	begin Menu_ViewToggleWindows;
		// same as user select View Panel and View Output
		Menu_ViewPanel();
		Menu_ViewOutput();
		ret();
	end Menu_ViewToggleWindows;
	
	procedure Menu_ViewHideAll; @noframe;
	begin Menu_ViewHideAll;
		PanelFold();	
		Output_View ( w.SW_HIDE);
		ret();
	end Menu_ViewHideAll;
	
	procedure CommandProcessor;	@noframe;
	
	
	// many menu items processing appear
	// here since they are not important enough
	// to clutter up the properties view with
	// individual procedures.
	
	val
		// for procedures called from WndProc, using HLA calling convention
		hwin	:text	:="[ebp+8]";
		umsg	:text	:="[ebp+12]";
		wparam	:text	:="[ebp+16]";
		lparam	:text	:="[ebp+20]";
	endval;
	
	begin CommandProcessor;

	_meud::	
			mov (curnode, eax);
			w.SendMessage(listeax.hwnd, w.EM_UNDO,0,0);
			ret();
			
	_merd::	
			mov (curnode, eax);
			w.SendMessage(listeax.hwnd, w.EM_REDO,0,0);
			ret();
			
	_mecut::
		mov (curnode, eax);
			w.SendMessage(listeax.hwnd, w.WM_CUT,0,0);
			ret();
	
	_mecpy::
		mov (curnode, eax);
		w.SendMessage(listeax.hwnd, w.WM_COPY,0,0);
		ret();
	
	_mepst::
		mov (curnode, eax);
		w.SendMessage(listeax.hwnd, w.WM_PASTE,0,0);
		ret();
	
	_medel::
		mov (curnode, eax);
		w.SendMessage(listeax.hwnd, w.WM_CLEAR,0,0);
			ret();
			
	_mesa::
			lea(chrg,eax);
			mov(0, (type w.CHARRANGE [eax]).cpMin);
			mov(-1,(type w.CHARRANGE [eax]).cpMax);
			mov (curnode, ecx);
			w.SendMessage(listecx.hwnd,w.EM_EXSETSEL,0,eax);
			ret();
		
	_mefnd::
			mov (curnode, eax);
			if (!eax) then
				ret();
			endif;
			cmp(core.hfind,0);
			jne _findopen;
			
			_find:	//dbg.put("creating find dialog");
					GetSelText(&findbuff);
					w.CreateDialogParam(core.hinst,val ID_FINDDLG,hwin,&Proc_FindDlg,false);
					ret();
			
			_findopen:w.SetFocus(core.hfind);
					ret();
			
	_mefnxt::
			mov (curnode, eax);
			if (!eax) then
				ret();
			endif;

			
			cmp(core.hfind,0);
			jne _cknbuf;
			
			_getnbuf:	GetSelText(&findbuff);
			
			_cknbuf:
					mov(findbuff[0],al);
					test(al,al);
					jz _xfnxt;
					find_next();
//					FindNext();
					// float	
			
			_xfnxt:	ret();
			
	_mefprv::
			mov (curnode, eax);
			if (!eax) then
				ret();
			endif;
			cmp(core.hfind,0);
			jne _ckpbuf;
			
			_getpbuf:	GetSelText(&findbuff);
			
			_ckpbuf:
					mov(findbuff[0],al);
					test(al,al);
					jz _xfprev;
//					FindPrev();
					find_prev();
					
			_xfprev:	ret();
			
	_mefrpl::
			mov (curnode, eax);
			if (listeax.hwnd = 0) then
				ret();
			endif;
			cmp(core.hfind,0);
			jne _findfoc;
			
			_setrep:
					GetSelText(&findbuff);
					w.CreateDialogParam(core.hinst,val ID_FINDDLG,hwin,&Proc_FindDlg,true);
					ret();
			
			_findfoc:	w.SetFocus(core.hfind);
					ret();
			
	_megoto::
			w.DialogBoxParam(core.hinst,val ID_GOTO,hwin,&Proc_Goto,false);
			ret();
		
//	_meind::	
//			IndentComment(w.VK_TAB,true);
//			ret();
//			
//	_meoutd::	
//			IndentComment(w.VK_TAB,false);
//			ret();
//			
	_mesbook::	
		USE (EBX);
			mov (curnode, ebx);
			w.SendMessage(listebx.hwnd, w.EM_EXGETSEL,0,&chrg);
			w.SendMessage(listebx.hwnd, w.EM_EXLINEFROMCHAR,0,chrg.cpMin);
			mov(eax, edi);
			w.SendMessage(listebx.hwnd,REM_GETBOOKMARK,edi,0);
			if(!eax) then
				w.SendMessage(listebx.hwnd, REM_SETBOOKMARK, edi,3);
			elseif (eax = 3) then
				w.SendMessage(listebx.hwnd, REM_SETBOOKMARK, edi,0);
			endif;
			updateDisplay (update_general);
		ENDUSE
		ret();
	
	_menbook::
		USE (EBX);
			mov (curnode, ebx);
			w.SendMessage(listebx.hwnd, w.EM_EXGETSEL, 0,&chrg);
			w.SendMessage(listebx.hwnd, w.EM_EXLINEFROMCHAR,0,chrg.cpMin);
			w.SendMessage(listebx.hwnd, REM_NXTBOOKMARK, eax, 3);
			if (eax != -1) then
				w.SendMessage(listebx.hwnd, w.EM_LINEINDEX, eax,0);
				mov	(eax, chrg.cpMin);
				mov	(eax, chrg.cpMax);
				w.SendMessage(listebx.hwnd, w.EM_EXSETSEL,0,&chrg);
				w.SendMessage(listebx.hwnd, REM_VCENTER,0,0);
				w.SendMessage(listebx.hwnd, w.EM_SCROLLCARET,0,0);
			endif;
		ENDUSE;
		ret();
			
	_mepbook::
		USE (EBX);
			mov (curnode, ebx);
			w.SendMessage(listebx.hwnd, w.EM_EXGETSEL,0,&chrg);
			w.SendMessage(listebx.hwnd, w.EM_EXLINEFROMCHAR, 0, chrg.cpMin);
			w.SendMessage(listebx.hwnd, REM_PRVBOOKMARK, eax,3);
			if (eax != -1) then
				w.SendMessage(listebx.hwnd, w.EM_LINEINDEX, eax,0);
				mov(eax,chrg.cpMin);
				mov(eax,chrg.cpMax);
				w.SendMessage(listebx.hwnd, w.EM_EXSETSEL,0,&chrg);
				w.SendMessage(listebx.hwnd, REM_VCENTER,0,0);
				w.SendMessage(listebx.hwnd, w.EM_SCROLLCARET,0,0);
			endif;
		ENDUSE;
		ret();
			
	_mecbook::	
		mov (curnode, eax);
		w.SendMessage (listeax.hwnd, REM_CLRBOOKMARKS,0,3);
		updateDisplay (update_general);
		ret();
			
	_expandall::	
		dbg.put ("expandall");
		USE (EBX);
			mov (curnode, ebx);	
			if (ebx) then
				w.SendMessage(listebx.hwnd, REM_EXPANDALL,0,0);
				w.SendMessage(listebx.hwnd, w.EM_SCROLLCARET,0,0);
				w.SendMessage (listebx.hwnd, REM_REPAINT,0,0);
			endif;
		ENDUSE;
		ret();
			
	_collapseall::
		dbg.put ("collapseall");
		USE (EBX);
			mov (curnode, ebx);
			if (ebx) then
				w.SendMessage (listebx.hwnd, REM_COLLAPSEALL, 0, 0); 
				w.SendMessage(listebx.hwnd, w.EM_SCROLLCARET,0,0);
				w.SendMessage (listebx.hwnd, REM_REPAINT,0,0);
			endif;
		ENDUSE;
		ret();
	
	_mocfnt::	
		mem2.fillMem(&cf,@size(cf),0);
		mov(@size(cf), cf.lStructSize);
		mov(hwin, cf.hWndOwner);
		mov(&mainfont, cf.lpLogFont);
		mov(w.CF_SCREENFONTS | w.CF_EFFECTS | w.CF_INITTOLOGFONTSTRUCT, cf.Flags);
		mov(core.col.txtcol, cf.rgbColors);
		//mov(curnode, ebx);
		w._ChooseFont(&cf);
		if (eax) then
			w.DeleteObject(core.hmainfont);
			mov	(mainfont.lfItalic, al);
			push (eax);
			w.CreateFontIndirect(&mainfont);
			mov	(eax, core.hmainfont);
			w.DeleteObject(core.hitalic);
			mov	(true, mainfont.lfItalic);
			w.CreateFontIndirect(&mainfont);
			mov	(eax, core.hitalic);
			pop	(eax);
			mov	(al, mainfont.lfItalic);
			mov	(cf.rgbColors, core.col.txtcol);
			setFormatAll();
			
			hed_ini.writeBin ("Fonts","code",&mainfont,@size(mainfont));
			hed_ini.writeBin ("Colors","col",&core.col,@size(core.col));
			
		endif;
		w.SetFocus( core.hwnd );
		ret();
			
	_molfnt::	
	//	USE (EBX);
		mem2.fillMem(&cf,@size(cf),0);
		mov(@size(cf), cf.lStructSize);
		mov(hwin, cf.hWndOwner);
		mov(&linefont, cf.lpLogFont);
		mov(w.CF_SCREENFONTS | w.CF_EFFECTS | w.CF_INITTOLOGFONTSTRUCT, cf.Flags);
		mov(core.col.lnrcol, cf.rgbColors);
		//mov (curnode, ebx);
		w._ChooseFont(&cf);
		if (eax) then
			w.DeleteObject(core.hlinefont);
			w.CreateFontIndirect(&linefont);
			mov(eax, core.hlinefont);
			mov(cf.rgbColors,core.col.lnrcol);
			//w.SendMessage(listebx.hwnd,REM_SETCOLOR,0,&core.col);
			setFormatAll();

			hed_ini.writeBin("Fonts", "line", &linefont, @size(linefont));
			hed_ini.writeBin ("Colors","col",&core.col,@size(core.col));
			
		endif;
		w.SetFocus( core.hwnd );
	//	ENDUSE;
		ret();

	_mhapi::
		mov(0,buffer[0]);
		if (hed_ini._readString ("Help", "1", stringbuffer)) then
			expandPathMacs (stringbuffer, stringbuffer);		
			if (str.length (stringbuffer) > 0) then
				mov (curnode, eax);
				w.SendMessage(listeax.hwnd,REM_GETWORD,@size(buffer),&buffer);
				if(buffer[0] <> 0) then
					w.WinHelp(hwin,stringbuffer, w.HELP_KEY,&buffer);
				else
					w.WinHelp(hwin,stringbuffer, w.HELP_INDEX,NULL);
				endif;				
			endif;

		endif;			
		ret();
			
	_ctrltab::
		if ( tabtool_getindex (curnode) != -1) then
			push (eax);
			w.SendMessage(core.htab, w.TCM_GETITEMCOUNT, 0, 0);
			pop (ecx);
			inc (ecx);
			cmp (ecx, eax);
			jl _ctrltab01;
			xor (ecx, ecx);
		_ctrltab01:
			w.SendMessage(core.htab,w.TCM_SETCURSEL, ecx,0);
			setupFind();
			call tabtool_activate;
		endif;
		ret();
	
	end CommandProcessor;
	
proc
	ShowPos :procedure( Line:uns32; nLines:uns32 );
	begin ShowPos;
		
		inc( Line );
		inc( nLines );
		str.put( stringbuffer, "Line: ", Line, "        Lines: ", nLines );
		w.SendMessage( core.hwnd, HED_SETSTATUS, STATUS_POSITION, stringbuffer );
	
	end ShowPos;
	
	
	AddMenus	:procedure;
	
	var
		file_menu		:dword;
		edit_menu		:dword;
		view_menu		:dword;
		tools_menu		:dword;
		options_menu	:dword;
		help_menu		:dword;
		recent_menu		:dword;
		build_str		:string;
	
	begin AddMenus;
		mov (str.talloc(1000), build_str);
		
		mov (w.CreateMenu(), file_menu);
		mov (w.CreateMenu(), edit_menu);
		mov (w.CreateMenu(), options_menu);
		mov (w.CreateMenu(), view_menu);
		mov (w.CreateMenu(), help_menu);
		mov (w.CreatePopupMenu(), recent_menu );

		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_NEW, "&New File	Ctrl+N");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_OPEN, "&Open File...	Ctrl+O");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_INSERT, "&Insert File at Cursor");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_OPEN_FOLDER, "Open &Folder...	Alt+O");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_OPENRECENT, "Recent Files");
		w.AppendMenu (file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_SAVE, "&Save	Ctrl+S");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_SAVEAS, "Save &As...	Alt+S");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_SAVEALL, "Save &All	Ctrl+Shift+S");
		w.AppendMenu (file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_CLOSE, "&Close File	Ctrl+F4");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_CLOSEALL, "Close All Files	Ctrl+Shift+F4");
		w.AppendMenu (file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_PAGESETUP, "Page Setup...");
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_PRINT, "Print...");
		w.AppendMenu (file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (file_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (file_menu, w.MF_STRING, IDM_FILE_EXIT, "&Quit	ESC");
		w.AppendMenu (core.hmenu, w.MF_POPUP, file_menu, "&File");

		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_UNDO, "&Undo	Ctrl+Z");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_REDO, "&Redo	Ctrl+Y");
		w.AppendMenu (edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_CUT, "&Cut	Ctrl+X");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_COPY, "Copy	Ctrl+C");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_PASTE, "&Paste	Ctrl+V");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_DELETE, "&Delete	Ctrl+d");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_SELECTALL, "Select &All	Ctrl+A");
		w.AppendMenu (edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_FIND, "Find...	Ctrl+F");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_NEXT, "Find Next	F3");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_PREV, "Find Prev	Ctrl+F3");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_REPLACE, "Replace...	Ctrl+R");
		w.AppendMenu (edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_GOTO, "Goto...	Ctrl+G");
		w.AppendMenu (edit_menu, w.MF_SEPARATOR, NULL, NULL);
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_SETMARK, "Bookmark Toggle	Shift+F8");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_NEXTBOOK, "Bookmark Next	F8");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_PREVBOOK, "Bookmark Prev	Ctrl+F8");
		w.AppendMenu (edit_menu, w.MF_STRING, IDM_EDIT_CLEARBOOK, "Clear All Bookmarks");
		w.AppendMenu (core.hmenu, w.MF_POPUP, edit_menu, "&Edit");

		w.AppendMenu (view_menu, w.MF_STRING, IDM_VIEW_STATUS, "Status Bar");
		w.AppendMenu (view_menu, w.MF_STRING, IDM_VIEW_OUTPUT, "Output Window	F11");
		w.AppendMenu (view_menu, w.MF_STRING, IDM_VIEW_PANEL, "Side Panel	Ctrl+B");
		w.AppendMenu (view_menu, w.MF_STRING, IDM_VIEW_HIDEALL, "Hide All	Ctrl+F12");
		w.AppendMenu (view_menu, w.MF_STRING, IDM_VIEW_TOGGLE, "Toggle	F12");
		w.AppendMenu (core.hmenu, w.MF_POPUP, view_menu, "&View");

		w.AppendMenu (tools_menu, w.MF_STRING, IDM_TOOL_CALC, "Calculator");
		w.AppendMenu (tools_menu, w.MF_STRING, IDM_TOOL_COLOR, "Color Picker");
		w.AppendMenu (tools_menu, w.MF_STRING, IDM_TOOL_CONSOLE, "Open Console");
		w.AppendMenu (tools_menu, w.MF_STRING, IDM_TOOL_RUN, "Run Command...");
		w.AppendMenu (core.hmenu, w.MF_POPUP, tools_menu, "&Tools");
		
		w.AppendMenu (options_menu, w.MF_STRING, IDM_OPTION_CODEFONT, "Editor Font...");
		w.AppendMenu (options_menu, w.MF_STRING, IDM_OPTION_LINEFONT, "Line Number Font...");
		w.AppendMenu (core.hmenu, w.MF_POPUP, options_menu, "&Options");

		w.AppendMenu (help_menu, w.MF_STRING, IDM_HELP_SHOWENV, "Help");
		w.AppendMenu (help_menu, w.MF_STRING, IDM_HELP_ABOUT, "About");
		w.AppendMenu (core.hmenu, w.MF_POPUP, help_menu, "&Help");

		w.SetMenu(core.hwnd, core.hmenu);

	end AddMenus;

	
	//bm=wndproc

	procedure	WndProc (lparam:dword; wparam:dword; umsg:uns32; hwin:dword);
	
	var
		mainrect		:hide.rect_t;
		toolrect		:hide.rect_t;
		_clientright	:dword;
		_clienttop		:dword;
		_clientbottom	:dword;

	// message tables
	static		
		// main_tbl is a jump table
		main_tbl	:dword;	@nostorage;
			dword	w.WM_COMMAND,		&_command;
			dword	w.WM_NOTIFY,		&_notify;
			dword	w.WM_SIZE,			&size_window;
			dword	w.WM_SETFOCUS,		&_focus;
			dword	w.WM_CONTEXTMENU,	&_context;
			dword	w.WM_DROPFILES,		&_drop;
			dword	w.WM_CLOSE,			&_close;
			dword	w.WM_DESTROY,		&_destroy;
			dword	w.WM_INITDIALOG,	&init_window;
			dword	HED_TOGGLEOUTPUT,	&_toggleout;
			dword	HED_SETSTATUS,		&_setstatus;
			dword	HED_SETINSERTMODE,	&_setinsert;
			
			// add more messages above here
			dword	0,					NULL;
			
		// menu_tbl is a call table
		menu_tbl	:dword;	@nostorage;
			dword	IDM_FILE_NEW,		&Menu_NewFile;
			dword	IDM_FILE_OPEN,		&Menu_OpenFile;
			dword	IDM_FILE_INSERT,	&Menu_InsertFile;
			dword	IDM_FILE_OPEN_FOLDER,&Menu_OpenFolder;
			dword	IDM_FILE_SAVE,		&Menu_SaveFile;
			dword	IDM_FILE_SAVEAS,	&Menu_SaveAs;
			dword	IDM_FILE_SAVEALL,	&Menu_SaveAll;
			dword	IDM_FILE_CLOSE,		&Menu_CloseFile;
			dword	IDM_FILE_CLOSEALL,	&Menu_CloseAll;
			dword	IDM_FILE_PAGESETUP,	&Menu_PageSetup;
			dword	IDM_FILE_PRINT,		&Menu_Print;
			dword	IDM_FILE_EXIT,		&Menu_Quit;
			
			dword	IDM_VIEW_STATUS,	&Menu_ViewStatusbar;
			dword	IDM_VIEW_OUTPUT,	&Menu_ViewOutput;
			dword	IDM_VIEW_PANEL,		&Menu_ViewPanel;
			dword	IDM_VIEW_HIDEALL,	&Menu_ViewHideAll;
			dword	IDM_VIEW_TOGGLE,	&Menu_ViewToggleWindows;
			
			dword	IDM_EDIT_UNDO,		&_meud;
			dword	IDM_EDIT_REDO,		&_merd;
			dword	IDM_EDIT_CUT,		&_mecut;
			dword	IDM_EDIT_COPY,		&_mecpy;
			dword	IDM_EDIT_PASTE,		&_mepst;
			dword	IDM_EDIT_DELETE,	&_medel;
			dword	IDM_EDIT_SELECTALL,	&_mesa;
			dword	IDM_EDIT_FIND,		&_mefnd;
			dword	IDM_EDIT_NEXT,		&_mefnxt;
			dword	IDM_EDIT_PREV,		&_mefprv;
			dword	IDM_EDIT_REPLACE,	&_mefrpl;
			dword	IDM_EDIT_GOTO,		&_megoto;
			dword	IDM_EDIT_SETMARK,	&_mesbook;
			dword	IDM_EDIT_NEXTBOOK,	&_menbook;
			dword	IDM_EDIT_PREVBOOK,	&_mepbook;
			dword	IDM_EDIT_CLEARBOOK,	&_mecbook;
			
			dword	IDM_HED_EXPANDALL,		&_expandall;	// expand/collapse buttons
			dword	IDM_HED_COLLAPSEALL,	&_collapseall;
			
			dword	IDM_OPTION_CODEFONT,	&_mocfnt;
			dword	IDM_OPTION_LINEFONT,	&_molfnt;
			
			dword	IDM_TOOL_CALC,			&Menu_ToolsCalc;
			dword	IDM_TOOL_COLOR,			&Menu_ToolsColor;
			dword	IDM_TOOL_CONSOLE,		&Menu_ToolsConsole;
			dword	IDM_TOOL_RUN,			&Menu_ToolsRun;
			
			dword	IDM_HELP_SHOWENV,		&Menu_Help_ShowEnv;
			dword	IDM_HELP_ABOUT,			&Menu_Help_About;
			dword	KEYBOARD_CTRLTAB,		&_ctrltab;
			
			// add more commands above here
			dword	0,						NULL;
			
	endstatic;
	
	begin	WndProc;
			push(ebx); push(esi); push(edi);
			mov(umsg,ecx);
			mov(&main_tbl,edx);
			sub(8,edx);
	_nxtmsg:
			add(8,edx);
			mov([edx],eax);
			cmp(eax,0);
			je _defproc;
			cmp(ecx,eax);
			jne _nxtmsg;
			jmp([edx+4]);
				
	_defproc:
			pop(edi); pop(esi); pop(ebx);
			w.DefWindowProc(hwin,umsg,wparam,lparam);
			exit WndProc;
	
	_toggleout:
			mov(IDM_VIEW_OUTPUT,eax);
			or(w.BN_CLICKED,eax);
			w.SendMessage(hwin,w.WM_COMMAND,eax,0);
			mov (lparam, eax);
			if (eax) then
				CloseOutputDelay(eax);
			endif;
			w.SetFocus(core.hwnd);
			jmp xWndProc;
	

	_setinsert:
		
		mov( curnode, ebx );
		if( ebx ) then
			
			if( listebx.hwnd <> 0 ) then

				w.GetWindowLong( listebx.hwnd, 0 );
				cmp( (type EDIT_CLASS[eax]).fOvr, 0 );
				if( @e ) then
					w.SendMessage( core.hwnd, HED_SETSTATUS, STATUS_INS, &szINS );
				else
					w.SendMessage( core.hwnd, HED_SETSTATUS, STATUS_INS, &szOVR );
				endif;
			
			endif;

		endif;
		jmp xWndProc;
		
	
	_setstatus:
			w.SendMessage(core.hsbr,w.SB_SETTEXT,wparam,lparam);
			jmp xWndProc;	
			
	_focus:
		mov (curnode, ebx);
		if (ebx) then
			w.SetFocus (listebx.hwnd);
		endif;
		
		jmp xWndProc;
			

	_context:
			mov	(lparam, eax);
			if (eax = -1) then

				w.GetCaretPos(&pt);
				w.GetFocus();
				mov	(eax, edx);
				w.ClientToScreen(edx, &pt);
			else
				and	($ffff, eax);
				mov	(eax, pt.x);
				mov	(lparam, eax);
				shr	(16, eax);
				mov	(eax, pt.y);
			endif;
	
			mov(wparam,eax);
			mov (curnode, ecx);
			if(eax = listecx.hwnd) then
				w.GetMenu(hwin);
				w.GetSubMenu(eax,1);
				w.TrackPopupMenu(eax, w.TPM_LEFTALIGN | w.TPM_RIGHTBUTTON, pt.x,pt.y,0,hwin,NULL); 
			
			elseif (eax = core.htab) then
				w.GetMenu(hwin);
				w.GetSubMenu(eax,0);
				w.TrackPopupMenu(eax, w.TPM_LEFTALIGN | w.TPM_RIGHTBUTTON, pt.x,pt.y,0,hwin,NULL); 
			endif;
			jmp xWndProc;
	
	_drop:
			dbg.put ("drop");
			w.DragQueryFile(wparam,0,&buffer,@size(buffer));
			str.a_cpyz(&buffer);
			mov(eax,openfile_s);
			//dbg.put ("buffer:", openfile_s);
			filesys.extractExt( openfile_s, stringbuffer );

				
				hed_openFile (openfile_s);
				
			Recent_Insert( openfile_s );
			UpdateMenu();
			str.free(openfile_s);
			updateDisplay (update_general);
			jmp xWndProc;
	
	
	_command:
			mov(wparam,ecx);
			mov(ecx,edx);
			movzx(cx,ecx);			// clear high-order word
			shr(16,edx);
			cmp(edx,w.BN_CLICKED);
			je _mf0;
			jmp xWndProc;
			
		_mf0:
			
			// determine if it is recent menu
			cmp (ecx, RECENT_MENU_START);
			jb _normalmenu;
			cmp (ecx, RECENT_MENU_END);
			jb _recentmenu;
			cmp (ecx, USER_MENU_END);
			jb _usermenu;
			jmp _normalmenu;
		
		_recentmenu:
			call Menu_RecentMenu;
			jmp xWndProc;
		
		_usermenu:
			call Menu_UserMenu;
			jmp xWndProc;
		
		_normalmenu:
			mov(&menu_tbl,edx);
			sub(8,edx);
		_nxtmnu:
			add(8,edx);
			mov([edx],eax);
			cmp(eax,0);
			je xWndProc;
			cmp(ecx,eax);
			jne _nxtmnu;
	
			call([edx+4]);
			jmp xWndProc;
	
	_notify:
		mov(lparam,edx);
		mov((type w.NMHDR [edx]).code, eax);
		
		if (eax = w.EN_SELCHANGE) then
			mov (curnode, ebx);
			if (! ebx) then
				jmp xWndProc;
			endif;

			// edit window has changed
			// update position display on status-bar
			mov(edx,edi);
			
			ShowPos( raseledi.line, raseledi.nlines );
				
			if (raseledi.seltyp = w.SEL_OBJECT) then
				w.SendMessage(listebx.hwnd, REM_GETBOOKMARK,raseledi.line,0);
				if (eax = RA_COLLAPSE) then
					w.SendMessage (listebx.hwnd, REM_COLLAPSE, raseledi.line, 0);
				elseif (eax = RA_EXPAND || eax = RA_EXPANDHIDDEN) then
					w.SendMessage(listebx.hwnd, REM_EXPAND, raseledi.line,0);
				else
					// clear bookmarks
					w.SendMessage(listebx.hwnd, REM_SETBOOKMARK, raseledi.line,0);
				endif;
	
			else
	
				w.SendMessage(listebx.hwnd,REM_SETHILITELINE,prvline,0);
				mov(raseledi.line,eax);
				mov(eax,prvline);
		
				push( edi );
				hed_ini.readInt( "HED", "Highlight Line" );
				pop( edi );
				if( eax ) then

					w.SendMessage(listebx.hwnd,REM_SETHILITELINE,prvline,2);

				endif;
				
				if (raseledi.fchanged) then
					
				 	if (! raseledi.nWordGroup) then
						w.SendMessage(listebx.hwnd, REM_SETCOMMENTBLOCKS, &szCmntStart,&szCmntEnd);
					endif;
		
					OnceMore:
					w.SendMessage(listebx.hwnd, REM_GETBOOKMARK, nlastline,0);
					push (eax);
					pop (edx);
					mov	(raseledi.line, eax);
					if (eax > nlastline) then
						inc	(nlastline);
						jmp	OnceMore;
					elseif (eax < nlastline) then
						dec (nlastline);
						jmp	OnceMore;
					endif;
				endif;
				
				mov	(raseledi.line, eax);
				mov (eax, nlastline);
				
			endif;
			w.SendMessage( listebx.hwnd, REM_GETWORD, @size(buffer), &buffer );
			updateDisplay (update_selection);
			
		elseif (eax = w.TTN_NEEDTEXT) then
	
			mov((type w.NMHDR [edx]).idFrom, edx);
			w.LoadStringA(core.hinst,edx,&buffer, @size(buffer));
			lea(eax,buffer);
			mov(lparam, edx);
			mov(eax,(type w.TOOLTIPTEXT [edx]).lpszText);
			
		elseif (eax = w.TCN_SELCHANGE) then
		
			mov((type w.NMHDR [edx]).hwndFrom, eax);
			if (eax = core.htab) then
				setupFind();
				call tabtool_activate;
			elseif (eax = core.hpaneltab) then
				call PanelActivate;
			endif;
			
		elseif (eax = w.TCN_SELCHANGING) then
			mov((type w.NMHDR [edx]).hwndFrom, eax);
			if (eax = core.hpaneltab) then
				panel_setfrom();
			endif;
		endif;
		jmp xWndProc;
		
	_close:	
		dbg.separator;
		dbg.put ("close");
		
		if (pathbuf[0] <> 0 ) then
			
			str.cpyz (&pathbuf, stringbuffer);
			if( filesys.hasExtension( stringbuffer ) ) then
				
				filesys.extractPath( stringbuffer, stringbuffer );

			endif;
			hed_ini.writeString( "HED", "Last Path", stringbuffer );
		endif;
		
		mov (curnode, eax);
		if (eax) then
			hed_ini.writeString ("HED", "Last File", listeax.fullname);
		endif;	
	
		closeAll();
		cmp (eax, true);
		je _cancel;
	
		if (core.hout) then
	       	w.DestroyWindow(core.hout);
		endif;

		w.GetWindowLong(hwin,w.GWL_STYLE);
		test(w.WS_MAXIMIZE,eax);
		jnz _setmax;	
		
		_savepos:	
				test(w.WS_MINIMIZE,eax);
				jnz _final;
				mov(false,settings.edtwin.fmax);
				w.GetWindowRect(hwin,&rect);
				mov(rect.left,settings.edtwin.x);
				mov(rect.top,settings.edtwin.y);
				mov(rect.right,eax);
				sub(rect.left,eax);
				mov(eax,settings.edtwin.wt);
				mov(rect.bottom,eax);
				sub(rect.top,eax);
				mov(eax,settings.edtwin.ht);
				jmp _final;
		
		_setmax:	
				mov(true,settings.edtwin.fmax);
				// float
					
		_final:
	
			
			hed_ini.writeBin ("Settings", "pos", &settings, @size(settings));
			hed_ini.writeBin ("Colors","User Colors", &CustColors, @size(CustColors));
			hed_ini.write (core.configmain);
			w.PostQuitMessage(0);
			
		_cancel:
			jmp xWndProc;

	size_window:
		
		// mainrect = entire client == shrink to accomodate edit window
		w.GetClientRect (hwin,mainrect);
		mov (mainrect.right,eax);
		cmp (eax, 15);
		jb xWndProc;	// too small
		cmp (mainrect.bottom, 15);
		jb xWndProc;
		mov (eax, _clientright);
		mov (mainrect.bottom, eax);
		
		mov (mainrect.top, eax);
		mov (eax, settings.hsplitbar.y);
		mov(eax, _clienttop);
		
		// check for status window
		if ( testz (STATUS,settings.winview)) then
			// HED
			w.ShowWindow(core.hsbr,w.SW_HIDE);
		else
			mov(lparam,eax);
			if (eax) then
				w.MoveWindow(core.hsbr,0,0,0,0,true);
			endif;
			w.GetWindowRect(core.hsbr,&rect);
			mov(rect.bottom,eax);
			sub(rect.top,eax);			// get height of statusbar
			sub(eax,mainrect.bottom);	// shrink the main client area from bottom
		endif;
	
		// find minimum height of hsplitbar
		mov ( mainrect.bottom,eax);
		mov (eax, _clientbottom);
		sub (_clienttop, eax);
		mov (eax, settings.hsplitbar.ht);
		
		// set vertical tab window
		mov (TABHT, eax);
		sub (eax, mainrect.right);
		w.MoveWindow (core.hpaneltab, mainrect.right, mainrect.top, TABHT, mainrect.bottom, true);
			
		// see if panel is active
		mov (settings.panelwin, eax);
		if (! eax) then
			w.ShowWindow (core.hHSplitBar, w.SW_HIDE);
			
		else
	
				// check for vertical splits
			mov (settings.hsplitbar.fmax, eax);
			mov (mainrect.right, ebx);
			mov (ebx, rect.right);
			sub (2, rect.right);
			sub(eax, ebx);
			jle xWndProc;	// not enough space
			mov (ebx, settings.hsplitbar.x);
			mov (mainrect.right, eax);
			sub (ebx, eax);
			sub (eax, mainrect.right);
			add (2, ebx);
	
			w.MoveWindow(core.hHSplitBar,settings.hsplitbar.x,settings.hsplitbar.y,3,settings.hsplitbar.ht,true);
			mov (settings.hsplitbar.x, eax);
			add (3, eax);
			mov (eax, rect.left);
			sub (eax, rect.right);
			
	//		dbg.put ("SIZE :: panel active = :", settings.panelactive);
			w.MoveWindow (settings.panelactive, rect.left, mainrect.top, rect.right, settings.hsplitbar.ht, true);	
		endif;
			
		// minimum vertical split
		mov (mainrect.right, eax);
		mov (eax, settings.vsplitbar.wt);
		
		// size tab window
		w.MoveWindow(core.htab,-1,mainrect.top,mainrect.right,TABHT,true);
		add(TABHT,mainrect.top);
		
		// check for output
		test(OUTPUT,settings.winview);
		jz _outputok;
		
		mov (lparam, eax);
		or (eax, eax);
		jz _updateoutput;
		// lparam is not zero, means window is moving, update vsplitbar position
		mov(settings.outwin.ht,eax);
		add(3,eax);
	
		mov(_clientbottom,ebx);
		_if(eax <= ebx)
			sub(eax,ebx);
			
			mov(ebx,settings.vsplitbar.y);
		_else
			jmp xWndProc;	// not enough client space
		_endif;
	
		_updateoutput:
			w.MoveWindow(core.hVSplitBar,0,settings.vsplitbar.y,settings.vsplitbar.wt,3,true);
				
			mov(0,rect.left);
			mov(settings.vsplitbar.y,eax);
			add(3,eax);
			mov(eax,rect.top);
			mov(mainrect.bottom,ebx);
			sub(eax,ebx);
			mov(ebx,rect.bottom);
			mov(mainrect.right,eax);
			mov(eax,rect.right);
	
			w.MoveWindow(core.hout,rect.left,rect.top,rect.right,rect.bottom,true);
			mov(settings.vsplitbar.y,eax);
			mov(eax,mainrect.bottom);
		
		_outputok:	
			// place editor window
			mov (curnode, ebx);
			if (ebx) then
				mov(mainrect.bottom,eax);
				sub(mainrect.top,eax);		// eax = height
				w.MoveWindow (listebx.hwnd, 0, mainrect.top, mainrect.right, eax, true);
			endif;
	
			w.GetClientRect(core.hwnd,&rect);
			w.InvalidateRect(core.hwnd,&rect,true);
			jmp xWndProc;
			
	init_window:
		
		pushabi;
		dbg.put(">init_window");
		
		// create fonts
		w.CreateFontIndirect(&linefont);
		mov(eax,core.hlinefont);
		w.CreateFontIndirect(&mainfont);
		mov(eax,core.hmainfont);
		mov(mainfont.lfItalic,al);
		push(eax);
		mov(true,mainfont.lfItalic);
		w.CreateFontIndirect(&mainfont);
		mov(eax,core.hitalic);
		pop(eax);
		mov(al,mainfont.lfItalic);
	
		w.CreateFontIndirect (&dialogfont);
		mov (eax, core.hdialogfont);
		
		// get dialog handles

		mov(hwin,eax);
		mov(eax,core.hwnd);
	
		w.CreateMenu();
		mov (eax, core.hmenu);
		AddMenus();
	
		// default position
		w.MoveWindow(hwin,settings.edtwin.x,settings.edtwin.y,settings.edtwin.wt,settings.edtwin.ht,true);
		
		// create status bar
		w.CreateStatusWindow ( w.WS_CHILD, NULL, hwin, IDC_SBR);
		mov(eax,core.hsbr);
		w.SendMessage(core.hsbr,w.SB_SETPARTS,STATUS_PARTS,&parts);
	
		w.CreateWindowEx (0, w.WC_TABCONTROL, NULL,
						w.TCS_TABS | w.TCS_SINGLELINE | w.TCS_RIGHTJUSTIFY | w.TCS_TOOLTIPS |
						w.TCS_FOCUSNEVER | w.WS_CHILD | w.WS_CLIPCHILDREN | w.WS_CLIPSIBLINGS |
						w.WS_TABSTOP | w.WS_VISIBLE, 0, 0, 0, TABHT,
						hwin, NULL, core.hinst, NULL );
		mov (eax, core.htab);
		w.SendMessage (eax, w.WM_SETFONT, core.hdialogfont, false);
	
		w.CreateWindowEx (0, w.WC_TABCONTROL, NULL,
						w.TCS_BOTTOM | w.TCS_TABS | w.TCS_SINGLELINE | w.TCS_VERTICAL |
						w.TCS_FOCUSNEVER | w.WS_CHILD | w.WS_CLIPCHILDREN | w.WS_CLIPSIBLINGS |
						w.WS_TABSTOP | w.WS_VISIBLE, 0, 0, TABHT, 0,
						hwin, NULL, core.hinst, NULL );
		mov (eax, core.hpaneltab);
		w.SendMessage (eax, w.WM_SETFONT, core.hdialogfont, false);
		
		PanelSetup (hwin);
		
		w.GetDlgItem(hwin,IDC_VSPLITBAR);
		mov(eax,core.hVSplitBar);
		w.SetWindowLong(core.hVSplitBar,w.GWL_WNDPROC,&Proc_VSplit);
		mov(eax,Proc_OldVSplit);
		w.GetDlgItem(hwin,IDC_HSPLITBAR);
		mov(eax,core.hHSplitBar);
	
		w.SetWindowLong(core.hHSplitBar,w.GWL_WNDPROC,&Proc_HSplit);
		mov(eax,Proc_OldHSplit);
	
		w.GetMenu(hwin);
		mov(eax,core.hmenu);
		
		test(STATUS,settings.winview);
		_if(@nz)
			w.CheckMenuItem(core.hmenu,IDM_VIEW_STATUS,(w.MF_BYCOMMAND | w.MF_CHECKED));
			w.ShowWindow (core.hsbr, true);
		_endif;
		
		w.CreateDialogParam(core.hinst,val ID_OUTPUT,hwin,&Proc_Output,false);
		if( bitSet( OUTPUT, settings.winview ) )then

			w.CheckMenuItem( core.hmenu, IDM_VIEW_OUTPUT, (w.MF_BYCOMMAND | w.MF_CHECKED) );
			w.ShowWindow( core.hout, w.SW_SHOW );

		else
			w.ShowWindow( core.hout, w.SW_HIDE );
		endif;
	
		w.CreateDialogParam(core.hinst,val ID_EXPLORER, hwin, &Proc_Explorer, false);
		w.SendMessage(core.hpaneltab, w.TCM_SETCURSEL, settings.panelwin, 0);
		
		w.ShowWindow (core.hexplorer, w.SW_HIDE);
		
		PanelViewWin();


		// if the previeous session had status bar active, update the vertical split
		// bar settings by the size of the status bar to avoid loosing size.
		test(STATUS,settings.winview);
		_if(@nz);
			w.GetWindowRect(core.hsbr,&rect);
			mov(rect.bottom,eax);
			sub(rect.top,eax);


			test(VSPLIT,settings.winview);
			_if(@nz)
				sub(eax,settings.vsplitbar.y);
			_endif;
		_endif;
		w.LoadCursor(core.hinst,val IDC_HSPLITTCUR);
		mov(eax,core.hHsplitcursor);
		w.LoadCursor(core.hinst,val IDC_VSPLITTCUR);
		mov(eax,core.hVsplitcursor);
	
		w.SendMessage(hwin, w.WM_SIZE, 0, 0);
	
		if (hed_ini._readString ("HED", "Last Path", stringbuffer)) then
			mov (stringbuffer, eax);
			zstr.cpy(eax,&pathbuf);
		endif;
		
		if (hed_ini.readBool ("HED", "Top Window")) then
			w.SetWindowPos(core.hwnd,w.HWND_TOPMOST,0,0,0,0,3);
		endif;
		
		// subclass the tab tool for context menu
		w.GetWindowLong (core.htab, w.GWL_WNDPROC);
		mov (eax, core.htaboldproc);
		w.SetWindowLong (core.htab, w.GWL_WNDPROC, &Proc_TabToolSubclass);
	
		// load user menu
		if (hed_ini.isSectionDefined ("User Menu")) then
			setupUserMenu();
		endif;
		
		updateDisplay (update_general);
				
		// update recent logs
		hed_ini.getItemCount( "Recent Files" );
		mov( eax, ecx );
		xor( edx, edx );
		while( edx < ecx ) do
			hed_ini.readItem( "Recent Files", edx, stringbuffer );
			if( ! filesys.exists( stringbuffer ) ) then
				hed_ini.deleteItem( "Recent Files", edx );
				dec( ecx );
			else
				inc( edx );
			endif;
		endwhile; 
		call UpdateMenu;
	
		dbg.put(">done InitDialog");
		popabi;
		jmp xWndProc;
	
	_destroy:
			w.DeleteObject(core.hitalic);
			w.DeleteObject(core.hmainfont);
			w.DeleteObject(core.hlinefont);
			w.DestroyCursor(core.hVsplitcursor);
			w.DestroyCursor(core.hHsplitcursor);
			// float
	xWndProc:
			pop(edi); pop(esi); pop(ebx);
			sub(eax,eax);
	end		WndProc;
	
	procedure initHED; @noframe;
	begin initHED;
	
		// general settings
		dbg.put ("Initialize");
		move( str.alloc (pathsize_c), core.homepath);
		move( str.alloc (pathsize_c), core.configmain);
		move( str.alloc (worksize_c), workpath);
		move( str.alloc (mastersize_c), stringbuffer);
		move( str.alloc (pathsize_c), core.projectpath);
			
		call arg.c;
		mov (eax,argc);
		os2.getmodulepath (core.homepath);
		
		filesys.extractPath( core.homepath, core.homepath );
		dbg.put ("core.homepath = ", core.homepath);
	
		str.put (core.configmain, core.homepath, dirsep_c, HED_INI_FILE);	
		try
			filesys.cd (core.homepath);
		anyexception
			toOutput ("Unable to change directory to ", core.homepath);	
		endtry;
		
		str.put (workpath, core.homepath, dirsep_c, HED_DEFAULTINI);	
		hed_default_ini.create_file ( workpath );

		if ( filesys.exists (core.configmain)) then
			hed_ini.create_file(core.configmain);
		else
			hed_default_ini.write(core.configmain);
			hed_default_ini.destroy();
			hed_ini.create_file (core.configmain);
		endif;
		
		if (hed_ini.readBool ("HED", "Tab Space")) then
			or (opt_exptabs, settings.options);
		endif;
		
		if (hed_ini.readBool ("HED", "Auto Indent")) then
			or (opt_indent, settings.options);
		endif;
		
		if (hed_ini.readBool ("HED", "Restore Work")) then
			or (opt_restore, settings.options);
		endif;
		
		if (hed_ini.readBool ("HED", "Auto Untitled")) then
			or (opt_autountitled, settings.options);
		endif;
		
		if (hed_ini.readBool ("HED", "Stdout Output")) then
			or (opt_console, settings.options);
		endif;
		
		hed_ini.readBin ("Settings", "pos", &settings, @size(settings));
		hed_ini.readBin ("Fonts", "code", &mainfont, @size(mainfont));
		hed_ini.readBin ("Fonts", "line", &linefont, @size(linefont));
		
		dbg.put("col");
		if (hed_ini.isKeyDefined ("Colors", "col")) then
			hed_ini.readBin ("Colors", "col", &core.col, @size(core.col));
		endif;

		if (hed_ini.isKeyDefined ("Colors", "User Colors")) then
			hed_ini.readBin ("Colors", "User Colors", &CustColors, @size(CustColors));
		endif;
		
		hed_ini.readInt ("HED", "Auto Untitled");
		mov (al, autountitled);

		str.cpy ("", stringbuffer);	
		if (hed_ini.readString ("HED", "User Path", stringbuffer)) then
			expandPathMacs (stringbuffer, stringbuffer);
			str.put2 (stringbuffer, ';');
			str.trim(stringbuffer);
			env2.put ("PATH", stringbuffer);
		endif;
		
		hed_ini.readUns( "HED", "tab" );
		if( eax ) then
			mov( al, settings.tab );
		else
			mov( 4, settings.tab );
		endif;
		
		if (hed_ini.readString ("HED", "Project Path", core.projectpath)) then
			expandPathMacs (core.projectpath, core.projectpath);
			str.trim (core.projectpath); 
		else
			filesys.gwd (core.projectpath);
		endif;
		dbg.put("init, project path = ", core.projectpath);
		
		fileList.create();
		setupFind();
		mov (0, settings.panelactive);

		initPrinter();

		dbg.put ("/initHED");
		ret();
	end initHED;
	
	//===============================================================
	// Main program begins here *************************************

	procedure RegisterWindow; @noframe;
	begin RegisterWindow;
		
		// register window classes
		mov(@size(w.WNDCLASSEX),wc.cbSize);
		mov(w.CS_HREDRAW | w.CS_VREDRAW,wc.style);
		mov(&WndProc,wc.lpfnWndProc);
		mov(NULL,wc.cbClsExtra);
		mov(w.DLGWINDOWEXTRA,wc.cbWndExtra);
		mov(core.hinst,wc.hInstance);
		mov(w.COLOR_BTNFACE+1, wc.hbrBackground);
		mov (NULL, wc.lpszMenuName);
		mov(&ClassName,wc.lpszClassName);
		w.LoadIcon(core.hinst,val IDB_JACKALICON);
		mov(eax,wc.hIcon);
		mov(eax,wc.hIconSm);
		w.LoadCursor(NULL,val w.IDC_ARROW);
		mov(eax,wc.hCursor);
		w.RegisterClassEx(wc);
		w.CreateDialogParam(core.hinst,val IDD_DLG,NULL,&WndProc,NULL);
		ret();
		
	end RegisterWindow;

	
	begin	HED_MAIN;
	
		// general init
		dbg.cls;
		dbg.put(">Begin [HED_MAIN]");
		#if( @thread )
			#print ("thread")
		#endif
		// initialize

		initHED();

	/***************************************************************/
	//			Main Window Setup									//
	/***************************************************************/
	WinMain:
		dbg.put(">>WinMain");
		w.GetModuleHandle(NULL);
		mov(eax,core.hinst);
		w.InitCommonControls();
	
		// install RAEdit.dll
		w.LoadLibrary(&RadDLL);
		if (! eax) then
			error.fatal("Data\RAEdit.dll not found");
			jmp _errorexit;
		endif;
		mov(eax,hradll);
		
		mov (false, open_override);
		
		RegisterWindow();
		
		if(settings.edtwin.fmax) then
			mov(w.SW_MAXIMIZE,eax);
		else
			mov(w.SW_SHOWNORMAL,eax);
		endif;

		w.ShowWindow(core.hwnd,eax);
		w.UpdateWindow(core.hwnd);
		initBF();		//setup the browsefolder structure, needs to be done after window creation
		

		dbg.put(">>args");
		dec (argc);
		if (argc > 0) then
			while (argc > 0 ) do
				arg.v (argc);
 
				mov (eax, openfile_s);
				if (str.eq (openfile_s, ".")) then
					// open folder
					filesys.gwd (core.projectpath);
					Explorer_LoadFolder (core.projectpath);
					mov (true, open_override);
				else
					//+ TODO: check if arg is a folder
					filesys.extractExt( openfile_s, stringbuffer );
					dbg.put("open :", openfile_s);
					hed_openFile (openfile_s);
					Recent_Insert( openfile_s );
					mov (true, open_override);
				endif;

				_nxtarg:
				dec (argc);
			endwhile;
		endif;

		if (!open_override) then
			if (hed_ini.readBool ("HED", "Restore Work")) then
				if (hed_ini.readString ("HED", "Last Path", workpath)) then
					Explorer_LoadFolder (workpath);
				endif;
				
				if (hed_ini.isKeyDefined ("HED", "Last File")) then
					hed_ini.readString ("HED", "Last File", workpath);
					hed_openFile (workpath);
				endif;
			endif;
		endif;

		updateDisplay (update_general);
		_msgloop:
			w.GetMessage(msg,NULL,0,0);
			cmp(eax,0);
			je xWinMain;
			w.IsDialogMessage(core.hfind,msg); and(eax,eax); jnz _msgloop;
			w.IsDialogMessage(core.hout,msg); and(eax,eax); jnz _msgloop;
	
	  		if (msg.message = w.WM_SYSKEYDOWN) then
   				if (msg.wParam = w.VK_MENU) then
        		// w.VK_MENU is sent by syskeydown message, as well as keydown message if
        		// alt is pressed after another modifier. such as control-alt 
        		dbg.put( "syskey down");
        		or (key_alt, modkey);
        		xor (eax, eax);
        		jmp _msgloop;
        	elseif (msg.wParam = w.VK_SHIFT) then
        		or (key_shift, modkey);
        		xor (eax, eax);
        		jmp _msgloop;
        	endif;

		elseif (msg.message = w.WM_SYSKEYUP) then
			if (msg.wParam = w.VK_MENU) then
     			and (!key_alt, modkey);
				xor (eax, eax);
        		jmp _msgloop;
        	elseif (msg.wParam = w.VK_SHIFT) then
        		dbg.put("up shift");
        		and (!key_shift, modkey);
        		xor (eax, eax);
        		jmp _msgloop;
        	endif;
        		
        elseif (msg.message = w.WM_SYSCHAR) then
        	dbg.put ("syschar  :", msg.wParam);
        	ProcessKeys (msg.wParam);
        	jmp _msgloop;
		
		elseif (msg.message = w.WM_KEYDOWN) then
     		if (msg.wParam = w.VK_CONTROL) then
	     		or (key_ctrl, modkey);
	     	elseif (msg.wParam = w.VK_SHIFT) then
	     		or (key_shift, modkey);
	     	elseif (msg.wParam = w.VK_MENU) then
	     		or (key_alt, modkey);
			else
				ProcessKeys (msg.wParam);
	
	    	endif;

		elseif (msg.message = w.WM_KEYUP) then
			if (msg.wParam = w.VK_CONTROL) then
     			and (!key_ctrl, modkey);
			elseif (msg.wParam = w.VK_SHIFT) then
				and (!key_shift, modkey);
			elseif (msg.wParam = w.VK_MENU) then
				and (!key_alt, modkey);

			endif;

		endif;
	
			
			w.TranslateMessage(msg);
			w.DispatchMessage(msg);
		jmp _msgloop;
	
	xWinMain:
		mov(msg.wParam,eax);
		_end:
		push (eax);
		w.FreeLibrary(hradll);
		pop (eax);
		_errorexit:
		os.exitProcess (eax);
	
	end		HED_MAIN;
	
